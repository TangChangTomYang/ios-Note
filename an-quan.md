## iOS 签名原理

原文参考：http://wereadteam.github.io

iOS 签名机制比较复杂,有各种证书: provisioning profile、entitlements、 certificateSigningRequest、p12 等等，很多也容易出错，下面来梳理下。



####一、RSA 非对称加密 数学原理 剖析

- 1> 选两个质数 `p` `q`, 相乘得到一个大整数 `n`, 例如p=61,q=53,得到 n=p*q=3233.

- 2> 在1 ~ n 之间随便选择一个质数 `e`, 例如：e = 17.

- 3> 经过一系列的数学算术计算 得到一个数字 `d`。件：
    **第3步得到的数字`d` 必须满足两个条件：**
    - 1> 通过 `n` 和 `e` 这两个数据进行数学运算后，可以通过`n` 和 `d` 去反解运算， 同理反过来也可以。
    - 2> 如果只知道 `n` 和 `e` ,要推倒出`d`，需要知道 `p` 和`q`，也就是需要把 `n` 因数分解。
    
上述的`(n，e)` 这两个数据在一起就是公约，`(n ， d)` 这两个数据就是私钥， 满足公钥加密私钥解密，或者私钥加密公钥解密。
**在公钥暴露下（只知道 n  和 e ） 要推倒出（n  和 d） 需要把大整数 n 因数分解， 目前因数分解只能靠暴力穷举，而 n 数 越大，越难穷举出 因数 p  和 q ,也就越安全， 当n 大到二进制数1024位或者2048位时，以目前的技术要破解几乎不可能，因此非常的安全**


数字d的算法可以参考文章： http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html




####二、数字签名


数字签名的作用是我对某份数据打个标记，表示我认可这份数据（我签了名），然后我把这个签了名的数据发送给其他人，其他人可以知道这份数据是经过我本人认证过的， 数据没有被篡改

![image](assets/appSign.png)

**之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位/ 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。**



####三、最简单的签名
要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。

![image](assets/appStoreSign.png)

如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。

但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：

- 开发 App 时可以直接把开发中的应用安装进手机进行调试。
- In-House 企业内部分发，可以直接安装企业证书签名后的 APP。
- AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。





































